> CPU가 컴퓨터에 수행능력에 있어서 가장 중요한 부품인데
> 어떤 방법으로 성능을 향상시키는지 알아보자.

## Clock
: 컴퓨터의 모든 부분을 빠르게 움직일 수 있게 하는 시간 단위, 주기에 맞춰 CPU가 명령어를 읽는다던지 ALU가 연산처리 한다던지 등
클럭속도 높 ->  보통 CPU의 성능이 높다 => 클럭속도 = CPU 속도 단위

❗️실제로 클럭이라 시간맞춰서 작동한다기보다는 고성능을 요구하면 빠르게 속도를 올리고, 그렇지 않으면 느리게 속도 조절한다(효율적으로 작동)

#### 클럭속도 
: Hz (헤르츠) 단위로 1초에 클럭이 몇 번 반복되는지를 나타냄
-> 클럭단위에 맞춰 1번 반복하면 1Hz, 100번 반복하면 100Hz
dg
cpu의 기본 속도 : 2.5GHz(25억 반복) / 최대 속도 : 4.9GHz(49억반복)


## Core
: 원래라면 CPU가 명령어를 실행하는 부품이지만 과학 발전으로 CPU 내에서 명령어를 실행하는 부품을 만들 수 있다 그래서 오늘날에는 명령어를 실행하는 부품이 core, 명령어를 실행하는 부품들의 집합을 CPU라고 한다

#### 멀티코어 CPU = 멀티코어 프로세서
:쿼드코어 헥사코어처럼 코어가 여러개

❗️코어를 늘리면 연산처리 속도도 빨라질까? -> 작업 분배에 따라 달라지는 것이지 무조건적으로 빨라지지는 않는다

## Thread
: 실행 흐름의 단위

### 하드웨어적 쓰레드
: CPU에서 사용하는 쓰레드, 하나의 코어가 동시에 처리하는 명령어 단위
ex) 8코어 16쓰레드 = 8개의 코어로 한 번에 16개 명령어를 동시에 처리하는 CPU = 하나의 코어당 2개의 명령어 처리가능

#### 멀티쓰레드 프로세서 = 멀티쓰레드 cpu
: 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
->하나의 명령어를 여러 명령어로 쪼개서 수행하는 **레지스터가 여러개 있으면 된다**

ex) 스택 포인터가 2개면 2개의 스택을 관리, 프로그램 카운터가 여러개, 명령어의 주소를 여러개 지정

❗️2코어 4스레드는 코어 2개에 4개씩 일을 처리하고 실제 코어수는 2개지만 메모리 입장에서는 쓰레드 흐름이 4개이기때문에 4개의 cpu가 돌아가는 것 같이 보인다 = 논리프로세서

**하이퍼쓰레딩(hyper-threading)** : 인텔의 멀티쓰레드 기술


### 소프트웨어적 쓰레드
: 프로그램에서 사용하는 쓰레드, 하나의 프로그램에서 독립적으로 실행되는 단위 = 하나의 메모리에 여러개의 기능 쓰레드를 실행가능
ex) java에서 배운 것처럼 여러기능을 동시, 병렬적으로 쓰레드 실행가능

<br>

---
## 명령어 병렬 처리 기법
: 쉬지 않고 알뜰하게 CPU를 병렬적으로 일하게 하는 방법(열쩡페이)
### 명령어 파이프 라이닝
: 명령어 처리과정을 클럭 단위로 보면, 인출(Fetch) -> 해석 -> 실행 -> 결과 저장을 공장생산라인에서 해결하는 것처럼 **해당 시간에 동시에 처리하는 과정**
					
    ❓파이프라인을 사용하지 않으면,
    하나의 명령어의 인출/해석/실행/저장 진행 후 다른 명령어 순차적으로 진행하게 된다

ex) 0초에 인출처리, 1초에 해석,인출 처리, 2초에 실행,해석,인출 처리.....

|명령어| 0초 | 1초 | 2초 | 3초 |4초|5초|6초|
|---| --- | --- | --- | --- |---|---|---|
|1|인출|해석|실행|저장|
|2||인출|해석|실행|저장|
|3|||인출|해석|실행|저장||
<br>

#### 파이프 라인 위험
: 특정상황에서는 성능향상에 실패하는 상황

1. **데이터 위험** : 데이터가 서로 의존한 경우
ex) 명령어1: K = k1+ k3, 명령어 2: Z = K+K4 -> K가 먼저 처리되어야 명령어 2가 진행되는데, 무작정 동시에 진행하는 경우이다
<br>
2. **제어 위험** : 분기 등으로 인한 프로그램 카운터 값에 갑작스러운 변화가 올 떄, 파이프라인이 쓸모가 없어지는 경우
-> 분기예측(Branch Prediction)를 이용해서 주소를 미리 예측해 방지한다<br>
ex) 명령어1, 2 따로 실행해서 파이프라이닝했는데, 합쳐서 명령어 3로 만들게 되면 파이프라이닝 한 의미가 없다
<br>
3. **구조적 위험** : 명령어들이 겹처서 ALU, 레지스터등을 동시에 사용하려는 경우, 충돌 위험

### 슈퍼스칼라
: 여러 개의 파이프 라이닝 = 공장 생산라인을 여러 개 두는 것
-> 파이프 라인 위험에 더욱 까다롭다

### 비순차적 명령어 처리 기법(OoOE)
: 순차적으로 처리하지 않고 합법적 새치기로 명령어 처리해서 파이프가 멈추는 것을 방지하는 방법(데이터 간의 의존성이 없는 경우)

ex) 명령어1: K = k1+ k3, 명령어 2: Z = K+K4 , 명령어 3: k1=2, 명령어 4 : k3=3 .. 
명령어 1이후에 2를 진행하기만 하면 되므로 명령어 3과 4는 먼저 진행해도 상관없다.

|명령어| 0초 | 1초 | 2초 | 3초 |4초|5초|6초|..|
|---| --- | --- | --- | --- |---|---|---|---|
|3|인출|해석|실행|저장|
|4||인출|해석|실행|저장|
|1|||인출|해석|실행|저장||
|2|||||||인출...|

<br>
<br>

---
> 파이프 라이닝이 하기 쉬운 명령어가 되어야 파이프라이닝에 최적화가 된다
그렇다면 파이프라이닝에 최적화 되는 명령어는 무엇일까?

## 명령어 집합 구조 (ISA)
: CPU가 이해할 수 있는 명령어들의 모음, 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속 = CPU의 언어, 생활양식

ex) 컴퓨터에는 어떤 명령어가 불러오기가 될 수 있지만 핸드폰에서는 같은 명령어가 삭제하기가 될 수 있다. 즉, ISA가 다르면 cpu가 이해하는 명령어, 어셈블리어도 달라진다

### CISC(Complex Instruction Set Computer)
: 복잡한 명령어 집합을 활용하는 컴퓨터(CPU) = 다양한 명령어를 활용하는 cpu 설계방식 = 다개국어 가능자

- 다양하기 때문에 형태와 크기가 다양한 **가변 길이 명령어 활용**

- 수용할 수 있는 크기가 다양해서 적은 크기도 수행할 수 있다 = 실행파일이 작아도 수행가능-> 알뜰살뜰

- 명령어 수행시간이 길다

- **단점1** : 워낙 많은 명령어를 알고 있어야 하기 때문에 복잡하고 파이프라인을 짜기가 쉽지 않다 -> 여러 클럭 주기가 동반 -> 파이프라인 위험부담 높아짐

- **단점2** : 계속 쓰는 명령어가 전체의 80%를 차지하기 때문에 CISC가 의미가 없어짐
<br>

### RISC(Reduced Instruction Set Computer)
: 수행시간이 짧고 규격과 되어있는 짧은 명령어를 활용하는 cpu 설계 방식

- 1클럭 내외로 실행되는 명령어 지향 -> 미니멀리즘 지향 -> 주소 지정 방식의 종류가 적음

- 규격화가 되어있어** 고정 길이 명령어** 활용 -> 파이프라이닝에 적합

- 직접 접근하는 명령어 : load, store 

- 레지스터 적극 활용 = CISC보다 많은 레지스터 이용 -> 수행 명령어 수가 많음