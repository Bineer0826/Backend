
> 컴퓨터는 명령어와 데이터의 정보만 이해한다고 했다 데이터보다 더 중요한 명령어에 대해서 자세하게 알아보자

## 고급언어와 저급언어
### 고급언어
: 사람을 위한 프로그래밍 언어(친숙도 good) -> java,C,,,


1. 컴파일 언어 : **컴파일 과정**으로 실행되는 언어 -> C

-  **컴파일(compile)** : 컴파일언어로 소스코드 전체가 저급언어로 변환되는 과정
-  **컴파일러** : 그 과정을 수행해주는 도구 -> 컴파일러로 인해 변환된 코드 : 목적코드(Object code)
- 오류 발생시, 전체실행불가

즉, 고급언어(소스코드) -> 컴파일(컴파일러) -> 저급언어(목적코드)

<br>


2. 인터프리터 언어 : 인터프리터에 의해 한줄씩 실행되는 언어 -> Python
- **인터프리터(interpreter)** : 한줄씩 저급언어로 변환하여 실행해주는 도구
- 소스코드 전체를 기다려야할 필요가 없다
- 오류가 발생해도 그 전 줄까지 실행해줌 -> 컴파일언어보다 빠르다는건 착각!

	무자르듯이 분리된 개념이라기보다는 이렇게 나눌 수 있구나 정도로 생각하자.




 ----
### 저급언어
: 컴퓨터가 직접 이해하고 실행할 수 있는 언어 -> 명령어



1. 기계어(machine code): 0과 1로 명령어 비트로 이루어진 언어
2. 어셈블리어 : 기계를 읽기 편한 상태로 변역한 언어
	-> 임베디드, 게임, 정보보안의 경우 어셈블리어를 다룬다
	-> 근본적인 컴퓨터의 실행 단계를 볼 수 있다

고급언어로 작성된 소스코드들을 저급언어(명령어)로 변환해야 컴퓨터가 이해한다



### 파일
목적파일 : 목적코드(저급언어)들로 이루어진 파일
텍스트파일 : 텍스트로 이루어진 파일
실행파일 : 실행코드로 이루어진 파일 -> .exe(윈도우)



#### 링킹(Linking) : 목적파일이 실행파일로 만드는 작업
  main.c 

      슈크림 붕어빵은 맛있어 -> main.o 010001001100101..
      화면출력

  sub.c

      슈크림 붕어빵은 맛있어 -> sub.o 01000100..

   변환했다고 바로 실행되지도 않고 외부 기능을 변환한 main.o에 연결짓는 과정이 필요하다
   <br>


---
## 명령어의 구조
```
연산코드   오퍼랜드
push	rbp
mov		rbp, rsp
```


### 연산코드(=연산자)
: 명령어가 수행할 연산
- **연산코드필드** : 연산코드가 담기는 영역

<br>
<br>

#### CPU가 공통으로 이해하는 연산코드
**데이터전송**
- MOVE : 데이터를 옮기기
- STORE : 메모리에 저장
- LOAD(FETCH) : 메모리에서 CPU로 데이터 불러오기
- PUSH : 스택에 데이터 저장
- POP : 스택의 최상단 데이터 불러오기

 **산술/논리연산**
- ADD / SUBTRACT /  MULTIPLY / DIVIDE : 덧뺼곱나 해라
- INCREMENT / DECREMENT : 오퍼랜드에 1을 더해라 / 빼라
- AND / OR / NOT : and or not 연산실행
- COMPARE : 두개의 숫자 혹은 true/false를 비교

**제어 흐름 변경**
- JUMP : 특정주소로 실행순서 옮기기
- CONDITIONAL JUMP :  조건에 부합할 때 특정 주소로 실행순서를 옮기기
- HALT : 프로그램 실행 멈추기
- CALL : 되돌아올 주소 저장하고 특정주소로 실행순서를 옮기기
- RETURN : CALL 호출 시, 저장했ㄷ너 주소로 돌아가기

**입출력 제어**
- READ(INPUT) : 특정 입출력 장치로부터 데이터 읽기
- WRITE(OUTPUT) : 특정 입출력 장치로 데이터 쓰기
- START IO : 입출력 장치 시작
- TEST IO : 입출력 장치의 상태 확인
<br>
<br>
<br>
### 오퍼랜드(=피연산자)
: 연산에 사용할 데이터 위치
- _**오퍼랜드 필드(주소필드)** : 오퍼랜드가 담기는 영역 -> 숫자문자나 메모리 주소, 레지스터 이름
- 없을 수도 있고 하나만 있을 수 있고 여러개 있을 수 있다 (`n-주소명령어`로 표시)

```
push.   rbp //1개 1-주소명령어
mov	    rbp, rsp //2게 2-주소명령어
ret	    //0개 0-주소명령어
```



### 주소지정 방식
: 오퍼랜드 필드에 데이터가 저장된 위치를 명시하면 연산에 사용할 데이터 위치를 찾는 방법
 - 유효 주소 : **연산코드**에 사용할 데이터가 저장된 위치
 
   1. 즉시_ : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
	   -> 데이터 크기가 작아지지만, 찾는 과정이 생략되어 빠르다
   
   2. 직접_ : 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
	   -> 유효주소라는 폴더를 만들어서 그 안에다가 저장
	   -> 데이터 크기는 즉시보다는 커졌지만 유효주소를 표현할 수 있는 범위가 줄어듦

   3. 간접_ : 유효주소의 주소를 오퍼랜드 필드에 명시하는 방식
	   -> 유효주소의 폴더의 위치를 오퍼랜드에 표시
	   -> 두번의 메모리 접근이 필요해서 좀 느리지만 유효주소 범위가 넓어진다

   4. 레지스터_ : 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드에 직접 명시하는 방식
	   -> 유효 주소 폴더 안에 cpu 레지스터에 접근함
	   -> 그렇지만 직접주소지정방식처럼 레지스터 크기에는 제한

   5. 레지스터 간접_ : 레지스터가 저장된 유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식
	   -> 유효주소 폴더의 위치를 오퍼랜드에 표시
	   -> ⭐️간접과 다르게 cpu와 메모리가 분리되어있어 한 번의 레지스터 접근이 필요하다는 장점 
<br>





---
![image.png](https://velog.velcdn.com/images/bineer0826/post/0d66ab53-80e6-44bd-a73c-a683816fc9a8/image.png)


### Stack (LIFO 자료구조)
: 비커같은 저장 공간/ 하단에서부터 차례대로 데이터를 저장하고 꺼낼 때는 나중에 저장한 자료를 먼저 꺼내는 데이터 관리 방식(후입선출 = LIFO)

- PUSH : 스택에 데이터 저장
- ==POP== : 스택에서 데이터 꺼내기



### Queue (FIFO 자료구조)
: 파이프같은 저장 공간/ 한 쪽에서는 데이터를 넣고 다른 한 쪽에서 데이터를 뺴는 방식(선입선출 = FIFO)


- [p] dkfsdf
- [c] asdfl
- [I] c dasdfl
- [2] asdf
- [3] asdff
- [3] 3번쨰가 말함요
- [4] 4번째가 말함


# 안녕하세요
## 반가워요
### 고맙습니다
==안녕하세요== ==ㅁㄴㅇㄹㅁㅇㄹ==
기울기!!!*ㅁㄴㅇㄹㅁㄴㄹ
*