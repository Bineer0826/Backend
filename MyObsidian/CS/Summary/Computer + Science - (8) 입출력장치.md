#혼공컴운 #CS 


> 외부 기기와 연결할 수 있는 원리와 장치에 대해서 알아보자
> 먼저, 외부 장치들을  입력하게 되면 서로 말이 달라서 데이터를 주고받는데 어려움이 된다..
> 그래서 직접 연결하지 않고 장치 컨트롤러를 이용한다


## 장치 컨트롤러(하드웨어적)
: 외부 장치와 컴퓨터가 컴퓨터 내부와 정보를 주고 받는 시스템

- cpu와 입출력 장치 간의 중개 = 번역기 역할
- 오류 컴출-> 번역역할에서 오류가 없는지..
- 데이터 버퍼링

### 버퍼링
: 전송률이 높은 장치와 낮은 장치사이에 주고받은 데이터를 ==**버퍼**==라는 임시공간에 저장해서 전송률을 맞추는 기능


### 구조

1. 데이터 레지스터 : 말 그대로 cpu와 입출력이 주고받을 데이터 담기는 공간 = 버퍼 역할
   -> 주고받는게 많아져서 RAM을 이용하기도 함
   
2. 상태 레지스터 : 입출력 작업이 완료되었는지 준비가 되었는지, 오류는 없는지 등 **상태 정보**가  저장되는 공간
   
3. 제어 레지스터 : 입출력 장치가 수행할 내용을 제어정보와 명령을 저장

❗️다들 버스를 타고 이동하거나 장치 컨트롤러에 연결 됨

<br>


----
## 장치 드라이버(소프트웨어적)
: 장치 컨트롤러의 동작을 감지하고 컴퓨터 내부와 정보를 주고받ㄹ을 수 있게 하는 프로그램
-> 앞에서 배운 내용과 연결되면 프로그램이기 때문에 실행과정에서 메모리에 저장함

❓ 누가 장치 드라이버를 실행시키는지??
	-> 운영체제 즉, 운영체제가 외부장치를 인식가능하면 장치 드라이버도 가능하고 그렇지 않으면 장치드라이버도 인식과 사용이 불가능하다




----
## 다양한 입출력 방법

### 프로그램 입출력(programmed I/O)
: 프로그램 속 명령어를 입출력하는 방법

#### cpu가 정보처리과정
메모리에 저장된 정보를 하드디스크(외부장치)에 백업한다고 가정함.

1. 하드디스크에 백업 = 하드디스크에 새로운 정보를 쓰는 것 -> cpu는 하드디스크 컨트롤러의 레지스터에 쓰기 명령
2. 하드디스크 컨트롤러는 준비 상태를 확인함 -> 준비가 되어있다면 상태 레지스터에 준비완료를 표시
3. cpu는 수시로 상태 레지스터를 읽어보며 준비 여부를 더블 체크
	   3-1. 준비가 된 경우, cpu가 백업할 메모리 정보를 데이터 레지스터에 작성
	   3-2. 준비가 되지 않는 경우, 1번부터 반복

이렇게, cpu가 레지스터에 접근해서 값을 읽고 쓰게 된다




#### cpu가 외부장치의 레지스터를 찾는 방식
##### 메모리 맵 입출력
:  입출력 장치에 접근하기 위한 주소를 하나의 주소 공간으로 간주하는 방법
-> ex) 자기 컴퓨터의 주소처럼 생각해서 512번지에 하드디스크 상태 레지스터에 명령을 내리면 상태값을 알아오는 방식
##### 고립형 입출력
: 메모리를 위한 주소 공간과 입출력 장치를 위한 주소공간을 분리하는 방법
-> ex) 메모리 하나에 나눠서 쓰는 방식이 아닌 주소공간하나를 새로 만들어서 거기에 주소를 지정함

| 메모리 맵 입출력 | 고립형 입출력 |
| ---- | ---- |
| 메모리와 입출력 장치는 같은 주소 공간 |  다른 공간 |
| 메모리의 주소 공간이 축소 | 축소X |
| 메모리와 입출력 장치에 같은 명령어 사용 가능 | 입출력 전용 명령어 사용 |





### 인터럽트 기반 입출력

> ch 4에서 인터럽트 요청 신호를 보내면 인터럽트 처리 프로그램에 가서 처리하고다시 되돌아 온다고 했는데, 이걸 이용한 입출력

: 입출력 장치가 아닌 장치 컨트롤러에 의해 인터럽트가 발생하게 된다


-> cpuu가 장치컨트롤러에 요청
-> 장치 컨트롤러가 중간에 인터럽트 기반을 이용해서 프린트 출력과 같은 일을 수행
-> cpu에게 전달 = 인터럽트 서비스 루틴 실행

❓ 여러 개의 인터럽트 요청이 온다면 cpu는 어떻게 처리??
-> 순서대로 처리한다.. but 우선순위를 고려해서 순서대로 처리한다 = NMI(무시할 수 없는 인터럽트)가 발생한 경우 부터 처리
-> ==**프로그래머블 인터럽트 컨트롤러(PIC)라는 하드웨어를 이용해서 우선순위 판별해줌**== = cpu의 비서같은 느낌?ㅋㅋㅋ





#### 프로그래머블 인터러블 컨트롤러 과정

1. 장치컨트롤러에서 PIC가 인터럽트 요청 신호들을 받아들임
2. 우선순위 판단 -> cpu 전달
3. cpu가 인터럽트 확인 신호
4. PIC는 데이터 버스를 통해 cpu에 인터럽트 벡터 보냄
5. cpu가 인터럽트 벡터를 통해 요청의 주체를 알게 되고 인터럽트 서비스 루틴을 알게 됨

❗️NMI는 우선순위가 넘버원이라 PIC가 관여하지 않는다







### DMA(Direct Memory Access) 입출력
: 앞의 두 방식은 cpu를 거쳐야하는데, 대용량일 경우 cpu가 부담이 커지기 때문에 cpu를 거치지 않아도 되는  직접적인 입출력 방식

- 시스템 버스에 DMA 컨트롤러가 따로 되어있어야 함 = 클론같은 느낌
#### 과정
1. cpu는 DMA에 정보들을 명령함
2. DMA는 cpu대신 장치 컨트롤러와 상호작용하여 작업 수행
3. DMA는 작업이 끝나면 cpu에게 전달

-> 이러한 방법으로 cpu는 입출력의 시작과 끝만 알면 된다

❗️하지만 시스템버스는 중복사용 불가이지 않나??
-> 그렇다 번갈아 나눠서 써야함... DMA가 cpu에게 시스템버스 이용을 빌리는 것 = 사이클 스틸링

#### 입출력 버스 사용

앞서, 시스템 버스 중복 사용이 불가하고 너무 자주사용하면 cpu가 느려지므로 입출력 버스에 DMA와 장치 컨트롤러를 배치한다