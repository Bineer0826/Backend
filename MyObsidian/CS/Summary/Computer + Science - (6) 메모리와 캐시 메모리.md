#CS #혼공컴운
<br>
<br>

> 지난 챕터에 이어서 이번에는 나머지 장치인 메모리에 대해 알아보자
> 앞서 배웠던 것처럼 RAM은 컴퓨터가 켜져 있을 때, 명령어와 데이터를 기억하는 장치!
> 보조기억 장치는 컴퓨터가 꺼져 있을 때, 저장하는 장치
<br>
<br>

# 메모리
## 특징

- 전원을 끄면 명령어와 데이터가 저장 X => **휘발성 저장장치**
- 주로 실행할 대상을 저장
- 다시 실행할 대상은 보조기억장치(비휘발성 저장장치) 저장 후, 복사해서 사용

<br>
<br>


## 용량과 성능

다시 실행하고 싶은 프로그램을 위해서 보조기억장치에서 가져와야 하는데, 만약 용량이 적으면 가져오는 일이 많아져 시간이 오래걸린다 

❗️but 필요 이상이 되면 성능과 관계가 없어진다 = 오가는 시간은 동일하기 때문이다

<br>
<br>


## RAM의 종류
### DRAM
: Dynamic RAM = 데이터가 동적으로 변하는(사라지는) RAM

- 시간이 지나면 저장된 데이터가 점점 사라짐
- 일정 주기로 데이터를 재활성화 필요!
- 소비전력 ⬇️ , 저렴, 집적도 ⬆️ => 대용량 RAM OK

### SRAM
: Static RAM = 데이터가 정적인(변하지 않는) RAM

- 시간이 지나도 데이터가 사라지지 않음
- 집적도 ⬇️ 소비전력 ⬆️, 비쌈
- 속도가 빨라야 하는 캐시메모리에서 사용

❗️ ==**전혀 공급이 되지 않을 경우에는 사라진다!!**==

### SDRAM
: Synchronous Dynamic RAM = 클럭신호와 동기화 된 발전된 형태의 DRAM

- 클럭 신호에 맞춰서 CPU와 정보를 주고받을 수 있음
- [[#DRAM]]의 특징을 다 가지고 있다

#### DDRAM
: Double data rate SDRAM = 대역폭(data rate)을 넓혀 속도를 빠르게 만든 SDRAM

☞대역폭은 데이터를 주고 받는 통로의 넓이 

- cpu와 클럭신호에 맞춰서 정보 주고 받음
- SDRAM보다 데이터 전송속도가 빠름
- [[#DRAM]]의 특징도 다 가지고 있음
#### SDRAM
: Sigle data rate SDRAM = 한 클럭당 하나씩의 데이터를 주고받는 SDRAM

<br>
<br>

## 주소 공간

> 메모리에 저장된 정보의 위치를 주소로 나타낼 수 있는데, 매번 시시각각 변하고 저장할떄마다 같은 주소의 보장도 없다 그래서 실행되고 있는 모든 프로그램의 주소를 알 수 없다.


### 물리주소
: 메모리가 사용하는 물리적인 주소 = **==실제로 정보가 저장된 하드웨어상의 주소==**
### 논리주소
: 실행되고 있는 프로그램이 사용하고 있는 주소 =  **==CPU가 이해하는 주소==**

즉, A게임의 물리주소가 10번지여도  실행되고 있다면 논리주소도 10번지가 가능하다
-> CPU는 이 두 주소를 어떻게 구별할까?

<br>
<br>

### 메모리 관리 장치(MMU)
: 논리주소를 물리주소로 변환해주는 하드웨어
- CPU와 메모리의 주소버스(통로)에서 위치하고 있다

	ex)
	물리주소 = 베이스 레지스터 값 + 논리주소
	베이스레지스터가 10000, A게임 논리주소 1~200번 할당된다면 CPU가 200번 게임실행 -> 메모리의 물리주소 10200번지가 실행된다
	
	**베이스레지스터** = 프로그램의 첫 물리주소(실질적인 주소)



#### 메모리 보호 기법
: 논리 주소 범위를 벗어나 명령어 실행을 방지하고 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 하는 것

- 한계 레지스터 담당 -> 범위를 검사함
- 논리 주소 범위는 한계 레지스터가 지정한 범위를 넘어설 수 없음


	ex)
	 논리주소 100번지 삭제와 숫자 100 삭제는 엄연히 다름!!! 그러므로 논리 주소의 범위를 한계 레지스터가 지정해준다
	베이스 레지스터 100, A 게임 논리주소 200, 한계레지스터 지정크기 100번지부터 150
	물리주소가 300이 되므로 한계 레지스터 범위(250)을 넘어가게 된다 -> **해당 논리주소를 가질 수 없게 된다--> 인터럽트 발생 --> 실행중단**


<br>
<br>

----

# 캐시 메모리

> 연산 능력이 아무리 빨라도 메모리와의 접근 속도가 느리면 아무짝도 쓸모가 없기 때문에 이를 극복하기 위해 탄생했다.

: CPU와 메모리 사이에 위치하고 레지스터보다 용량이 크고 메모리보다 빠른 SRAM(동기화메모리)

- 미리 메모리가 캐시 메모리에 갔다놓음
- 캐시메모리는 일반 메모리보다 빠르므로 CPU와 호응

##### 분리형 캐시 메모리
: 더 빠르게 접근하기 위해  명령어만 저장하는 **L1I**, **데이터만 저장하는 L1D**로 분리하는 경우


<br>
<br>

### 저장 장치 계층 구조
: CPU에 얼마나 가까운지 계층적으로 나타내는구조

- 아래로 갈수록 CPU와 멀다
- L1, L2는 코어 내부에 위치
- L3 캐시는 코어 외부에 위치

![[Pasted image 20240109164624.png]] 



<br>
<br>


### 저장
캐시 메모리는 일반 메모리보다 CPU에 가깝기 때문에 메모리 계층구조에 따라 용량이 작을 수 밖에 없다.
즉, 메모리의 일부를 캐시에 저장한다
**CPU에서 사용할 법한 대상들을 예측해서 저장**
##### 1. 캐시 히트(cache hit)
:  예측한 데이터가 CPU에 활용될 경우

##### 2. 캐시 미스(cache miss)
: 예측한 데이터가 CPU에 활용되지 않고 CPU가 직접 데이터를 가져와야하는 경우
-> 자주 발생하면 캐시 메모리를 이용할 수 없어서 성능저하!

##### 3. 캐시 적중률
: 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
-> 대부분 캐시 적중률은 85% ~ 95%


<br>
<br>


### 참조 지역성 원리
: 한 가지의 원칙에 따라 메모리부터 가져올 데이터를 결정하는 원리 = 캐시 만의 알고리즘이랄까?ㅎㅎ

###### 1. 시간 지역성
: CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향

###### 2. 공간 지역성
: CPU는 접근한 메모리 근처에 접근하려는 경향





----



출처

[[#저장 장치 계층 구조]] : https://news.skhynix.co.kr/hs-fs/hubfs/A_Medialibrary/10_Newsroom%20Upload/2023/9%EC%9B%94/%EC%B5%9C%EB%A6%AC%EB%85%B8%EA%B5%90%EC%88%98%EB%8B%98_5%ED%8E%B8/%EB%B0%98%EB%8F%84%EC%B2%B4%EC%9D%98%EC%9D%B4%ED%95%B4_%EC%83%88%EB%A1%9C%EC%9A%B4_%EB%A9%94%EB%AA%A8%EB%A6%AC_%ED%83%84%EC%83%9D%EC%9D%84_%EC%9C%84%ED%95%9C_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%86%8C%EC%9E%90%EC%9D%98_%EC%A1%B0%EA%B1%B4%EB%93%A4_02.png?width=1600&height=1072&name=%EB%B0%98%EB%8F%84%EC%B2%B4%EC%9D%98%EC%9D%B4%ED%95%B4_%EC%83%88%EB%A1%9C%EC%9A%B4_%EB%A9%94%EB%AA%A8%EB%A6%AC_%ED%83%84%EC%83%9D%EC%9D%84_%EC%9C%84%ED%95%9C_%EB%A9%94%EB%AA%A8%EB%A6%AC_%EC%86%8C%EC%9E%90%EC%9D%98_%EC%A1%B0%EA%B1%B4%EB%93%A4_02.png



참고문헌

[[Computer + Science - (6) 메모리와 캐시 메모리]] https://namu.wiki/w/RAM